"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from datetime import datetime
from glean import errors, models, utils
from glean._hooks import HookContext
from glean.types import OptionalNullable, UNSET
from glean.utils import get_security_from_env
from typing import List, Mapping, Optional, Union


class Announcements(BaseSDK):
    def create(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.CreateAnnouncementRequestChannel] = None,
        post_type: Optional[models.CreateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Create Announcement

        Create a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            create_announcement_request=models.CreateAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/createannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_announcement_request,
                False,
                False,
                "json",
                models.CreateAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_async(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.CreateAnnouncementRequestChannel] = None,
        post_type: Optional[models.CreateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Create Announcement

        Create a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            create_announcement_request=models.CreateAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/createannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_announcement_request,
                False,
                False,
                "json",
                models.CreateAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_draft(
        self,
        *,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        title: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.CreateDraftAnnouncementRequestChannel] = None,
        post_type: Optional[models.CreateDraftAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        id: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Create draft Announcement

        Create a draft of a textual announcement visible to some set of users based on department and location.

        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param id: The opaque id of the parent announcement.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreatedraftannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            create_draft_announcement_request=models.CreateDraftAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/createdraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_draft_announcement_request,
                False,
                False,
                "json",
                models.CreateDraftAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createdraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_draft_async(
        self,
        *,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        title: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.CreateDraftAnnouncementRequestChannel] = None,
        post_type: Optional[models.CreateDraftAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        id: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Create draft Announcement

        Create a draft of a textual announcement visible to some set of users based on department and location.

        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param id: The opaque id of the parent announcement.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreatedraftannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            create_draft_announcement_request=models.CreateDraftAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/createdraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_draft_announcement_request,
                False,
                False,
                "json",
                models.CreateDraftAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createdraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def delete(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Announcement

        Delete an existing user-generated announcement.

        :param id: The opaque id of the announcement to be deleted.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            delete_announcement_request=models.DeleteAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deleteannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_announcement_request,
                False,
                False,
                "json",
                models.DeleteAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_async(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete Announcement

        Delete an existing user-generated announcement.

        :param id: The opaque id of the announcement to be deleted.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            delete_announcement_request=models.DeleteAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deleteannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_announcement_request,
                False,
                False,
                "json",
                models.DeleteAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def delete_draft(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete draft Announcement

        Delete an existing user-generated draft Announcement.

        :param id: The opaque id of the announcement to be deleted.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletedraftannouncementRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            delete_announcement_request=models.DeleteAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deletedraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_announcement_request,
                False,
                False,
                "json",
                models.DeleteAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deletedraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_draft_async(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete draft Announcement

        Delete an existing user-generated draft Announcement.

        :param id: The opaque id of the announcement to be deleted.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletedraftannouncementRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            delete_announcement_request=models.DeleteAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deletedraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_announcement_request,
                False,
                False,
                "json",
                models.DeleteAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deletedraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAnnouncementResponse:
        r"""Read Announcement

        Read the details of an Announcement given its ID.

        :param id: The id of the announcement to be retrieved.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            get_announcement_request=models.GetAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/getannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_announcement_request,
                False,
                False,
                "json",
                models.GetAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetAnnouncementResponse)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_async(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAnnouncementResponse:
        r"""Read Announcement

        Read the details of an Announcement given its ID.

        :param id: The id of the announcement to be retrieved.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            get_announcement_request=models.GetAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/getannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_announcement_request,
                False,
                False,
                "json",
                models.GetAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.GetAnnouncementResponse)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_draft(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDraftAnnouncementResponse:
        r"""Read draft Announcement

        Read the details of an existing user-generated draft Announcement.

        :param id: The id of the announcement to be retrieved.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetdraftannouncementRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            get_announcement_request=models.GetAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/getdraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_announcement_request,
                False,
                False,
                "json",
                models.GetAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getdraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.GetDraftAnnouncementResponse
            )
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_draft_async(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDraftAnnouncementResponse:
        r"""Read draft Announcement

        Read the details of an existing user-generated draft Announcement.

        :param id: The id of the announcement to be retrieved.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetdraftannouncementRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            get_announcement_request=models.GetAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/getdraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_announcement_request,
                False,
                False,
                "json",
                models.GetAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getdraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.GetDraftAnnouncementResponse
            )
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list(
        self,
        *,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        channel: Optional[models.AnnouncementChannel] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListAnnouncementsResponse:
        r"""List Announcements

        List Announcement details for all Announcements matching the given criteria.

        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListannouncementsRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            list_announcements_request=models.ListAnnouncementsRequest(
                channel=channel,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/listannouncements",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.list_announcements_request,
                False,
                False,
                "json",
                models.ListAnnouncementsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="listannouncements",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.ListAnnouncementsResponse)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_async(
        self,
        *,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        channel: Optional[models.AnnouncementChannel] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListAnnouncementsResponse:
        r"""List Announcements

        List Announcement details for all Announcements matching the given criteria.

        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListannouncementsRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            list_announcements_request=models.ListAnnouncementsRequest(
                channel=channel,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/listannouncements",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.list_announcements_request,
                False,
                False,
                "json",
                models.ListAnnouncementsRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="listannouncements",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.ListAnnouncementsResponse)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def preview(
        self,
        *,
        text: str,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewStructuredTextResponse:
        r"""Preview Announcement

        Generate a preview for a user-generated Announcement from structured text.

        :param text:
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewannouncementRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            structured_text_mutable_properties=models.StructuredTextMutableProperties(
                text=text,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/previewannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.structured_text_mutable_properties,
                False,
                False,
                "json",
                models.StructuredTextMutableProperties,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="previewannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.PreviewStructuredTextResponse
            )
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def preview_async(
        self,
        *,
        text: str,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewStructuredTextResponse:
        r"""Preview Announcement

        Generate a preview for a user-generated Announcement from structured text.

        :param text:
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewannouncementRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            structured_text_mutable_properties=models.StructuredTextMutableProperties(
                text=text,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/previewannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.structured_text_mutable_properties,
                False,
                False,
                "json",
                models.StructuredTextMutableProperties,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="previewannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.PreviewStructuredTextResponse
            )
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def preview_draft(
        self,
        *,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        draft: Optional[Union[models.UgcDraft, models.UgcDraftTypedDict]] = None,
        draft_spec: Optional[
            Union[models.DocumentSpecUnion, models.DocumentSpecUnionTypedDict]
        ] = None,
        type_: Optional[models.UgcType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewUgcResponse:
        r"""Preview draft Announcement

        Generates a preview for a user-generated Announcement from a draft.

        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param draft:
        :param draft_spec:
        :param type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewannouncementdraftRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            preview_ugc_request=models.PreviewUgcRequest(
                draft=utils.get_pydantic_model(draft, Optional[models.UgcDraft]),
                draft_spec=utils.get_pydantic_model(
                    draft_spec, Optional[models.DocumentSpecUnion]
                ),
                type=type_,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/previewannouncementdraft",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.preview_ugc_request,
                False,
                False,
                "json",
                models.PreviewUgcRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="previewannouncementdraft",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.PreviewUgcResponse)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def preview_draft_async(
        self,
        *,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        draft: Optional[Union[models.UgcDraft, models.UgcDraftTypedDict]] = None,
        draft_spec: Optional[
            Union[models.DocumentSpecUnion, models.DocumentSpecUnionTypedDict]
        ] = None,
        type_: Optional[models.UgcType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PreviewUgcResponse:
        r"""Preview draft Announcement

        Generates a preview for a user-generated Announcement from a draft.

        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param draft:
        :param draft_spec:
        :param type:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PreviewannouncementdraftRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            preview_ugc_request=models.PreviewUgcRequest(
                draft=utils.get_pydantic_model(draft, Optional[models.UgcDraft]),
                draft_spec=utils.get_pydantic_model(
                    draft_spec, Optional[models.DocumentSpecUnion]
                ),
                type=type_,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/previewannouncementdraft",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.preview_ugc_request,
                False,
                False,
                "json",
                models.PreviewUgcRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="previewannouncementdraft",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.PreviewUgcResponse)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def publish(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Publish draft Announcement

        Promote a draft Announcement to be visible to others.

        :param id: The opaque id of the draft announcement to be published.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PublishdraftannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            publish_draft_announcement_request=models.PublishDraftAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/publishdraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.publish_draft_announcement_request,
                False,
                False,
                "json",
                models.PublishDraftAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="publishdraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def publish_async(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Publish draft Announcement

        Promote a draft Announcement to be visible to others.

        :param id: The opaque id of the draft announcement to be published.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PublishdraftannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            publish_draft_announcement_request=models.PublishDraftAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/publishdraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.publish_draft_announcement_request,
                False,
                False,
                "json",
                models.PublishDraftAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="publishdraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def unpublish(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Unpublish Announcement

        Unpublish an Announcement to hide it from users.

        :param id: The opaque id of the announcement to be unpublished.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UnpublishannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            unpublish_announcement_request=models.UnpublishAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/unpublishannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.unpublish_announcement_request,
                False,
                False,
                "json",
                models.UnpublishAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="unpublishannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def unpublish_async(
        self,
        *,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Unpublish Announcement

        Unpublish an Announcement to hide it from users.

        :param id: The opaque id of the announcement to be unpublished.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UnpublishannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            unpublish_announcement_request=models.UnpublishAnnouncementRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/unpublishannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.unpublish_announcement_request,
                False,
                False,
                "json",
                models.UnpublishAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="unpublishannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.UpdateAnnouncementRequestChannel] = None,
        post_type: Optional[models.UpdateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Update Announcement

        Update a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param id: The opaque id of the announcement.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            update_announcement_request=models.UpdateAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/updateannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_announcement_request,
                False,
                False,
                "json",
                models.UpdateAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_async(
        self,
        *,
        start_time: datetime,
        end_time: datetime,
        title: str,
        id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.UpdateAnnouncementRequestChannel] = None,
        post_type: Optional[models.UpdateAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Update Announcement

        Update a textual announcement visible to some set of users based on department and location.

        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param id: The opaque id of the announcement.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            update_announcement_request=models.UpdateAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/updateannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_announcement_request,
                False,
                False,
                "json",
                models.UpdateAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_draft(
        self,
        *,
        draft_id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        title: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.UpdateDraftAnnouncementRequestChannel] = None,
        post_type: Optional[models.UpdateDraftAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        id: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Update draft Announcement

        Update a textual Announcement visible to some set of users based on department and location.

        :param draft_id: The opaque id of the draft.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param id: The opaque id of the announcement.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdatedraftannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            update_draft_announcement_request=models.UpdateDraftAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
                id=id,
                draft_id=draft_id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/updatedraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_draft_announcement_request,
                False,
                False,
                "json",
                models.UpdateDraftAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updatedraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_draft_async(
        self,
        *,
        draft_id: int,
        x_scio_actas: Optional[str] = None,
        x_glean_auth_type: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        title: Optional[str] = None,
        body: Optional[
            Union[models.StructuredText, models.StructuredTextTypedDict]
        ] = None,
        emoji: Optional[str] = None,
        thumbnail: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        banner: Optional[Union[models.Thumbnail, models.ThumbnailTypedDict]] = None,
        audience_filters: Optional[
            Union[List[models.FacetFilter], List[models.FacetFilterTypedDict]]
        ] = None,
        source_document_id: Optional[str] = None,
        hide_attribution: Optional[bool] = None,
        channel: Optional[models.UpdateDraftAnnouncementRequestChannel] = None,
        post_type: Optional[models.UpdateDraftAnnouncementRequestPostType] = None,
        is_prioritized: Optional[bool] = None,
        view_url: Optional[str] = None,
        id: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Announcement:
        r"""Update draft Announcement

        Update a textual Announcement visible to some set of users based on department and location.

        :param draft_id: The opaque id of the draft.
        :param x_scio_actas: Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
        :param x_glean_auth_type: Auth type being used to access the endpoint (should be non-empty only for global tokens).
        :param start_time: The date and time at which the announcement becomes active.
        :param end_time: The date and time at which the announcement expires.
        :param title: The headline of the announcement.
        :param body:
        :param emoji: An emoji used to indicate the nature of the announcement.
        :param thumbnail:
        :param banner:
        :param audience_filters: Filters which restrict who should see the announcement. Values are taken from the corresponding filters in people search.
        :param source_document_id: The Glean Document ID of the source document this Announcement was created from (e.g. Slack thread).
        :param hide_attribution: Whether or not to hide an author attribution.
        :param channel: This determines whether this is a Social Feed post or a regular announcement.
        :param post_type: This determines whether this is an external-link post or a regular announcement post. TEXT - Regular announcement that can contain rich text. LINK - Announcement that is linked to an external site.
        :param is_prioritized: Used by the Social Feed to pin posts to the front of the feed.
        :param view_url: URL for viewing the announcement. It will be set to document URL for announcements from other datasources e.g. simpplr. Can only be written when channel=\"SOCIAL_FEED\".
        :param id: The opaque id of the announcement.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdatedraftannouncementRequestRequest(
            x_scio_actas=x_scio_actas,
            x_glean_auth_type=x_glean_auth_type,
            update_draft_announcement_request=models.UpdateDraftAnnouncementRequest(
                start_time=start_time,
                end_time=end_time,
                title=title,
                body=utils.get_pydantic_model(body, Optional[models.StructuredText]),
                emoji=emoji,
                thumbnail=utils.get_pydantic_model(
                    thumbnail, Optional[models.Thumbnail]
                ),
                banner=utils.get_pydantic_model(banner, Optional[models.Thumbnail]),
                audience_filters=utils.get_pydantic_model(
                    audience_filters, Optional[List[models.FacetFilter]]
                ),
                source_document_id=source_document_id,
                hide_attribution=hide_attribution,
                channel=channel,
                post_type=post_type,
                is_prioritized=is_prioritized,
                view_url=view_url,
                id=id,
                draft_id=draft_id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/updatedraftannouncement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_draft_announcement_request,
                False,
                False,
                "json",
                models.UpdateDraftAnnouncementRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updatedraftannouncement",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Announcement)
        if utils.match_response(http_res, ["400", "401", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.GleanError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
